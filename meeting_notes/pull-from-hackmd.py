"""Pull meeting notes from HackMD team space by tags.

Generated by ChatGPT.
Requires a HackMD API token with team read access.
"""

import re
import pathlib
import requests
from datetime import datetime, timezone

API_BASE = "https://api.hackmd.io/v1"
TEAM = "aeon-toolkit"
TAGS = {"aeon-module-meeting", "aeon-regular-dev-meeting"}
OUT_DIR = pathlib.Path("export")
MEETING_NOTES_DIR = pathlib.Path("./")

DATE_PATTERNS = [
    # pattern, list of candidate strptime formats to try
    (r"\b(\d{4}-\d{2}-\d{2})\b", ["%Y-%m-%d"]),                                 # 2025-09-13
    (r"\b(\d{4}/\d{2}/\d{2})\b", ["%Y/%m/%d"]),                                 # 2025/09/13
    (r"\b(\d{2}-\d{2}-\d{4})\b", ["%d-%m-%Y"]),                                 # 13-09-2025
    (r"\b(\d{2}/\d{2}/\d{4})\b", ["%d/%m/%Y"]),                                 # 13/09/2025
    (r"\b([A-Za-z]{3,9}\s+\d{1,2},\s*\d{4})\b", ["%B %d, %Y", "%b %d, %Y"]),    # September 13, 2025 / Sep 13, 2025
    (r"\b(\d{1,2}\s+[A-Za-z]{3,9}\s+\d{4})\b", ["%d %B %Y", "%d %b %Y"]),       # 13 September 2025 / 13 Sep 2025
    (r"\b([A-Za-z]{3}\s+\d{1,2}\s+\d{4})\b", ["%b %d %Y"]),                     # Sep 13 2025
]

def session_with_token(token):
    s = requests.Session()
    if token:
        s.headers.update({"Authorization": f"Bearer {token}"})
    s.headers.update({"Accept": "application/json", "User-Agent": "aeon-basic-export/0.3"})
    return s

def require_ok(r):
    if r.status_code == 401:
        raise SystemExit("Unauthorized (401). Set HACKMD_API_TOKEN to a valid token.")
    if r.status_code >= 400:
        raise SystemExit(f"HTTP {r.status_code}: {r.text[:300]}")
    return r

def list_team_notes(s):
    url = f"{API_BASE}/teams/{TEAM}/notes"
    return require_ok(s.get(url, timeout=30)).json()

def get_note(s, note_id):
    url = f"{API_BASE}/notes/{note_id}"
    return require_ok(s.get(url, timeout=30)).json()

def _try_parse_with_formats(text: str, fmts: list[str]) -> str | None:
    for fmt in fmts:
        try:
            return datetime.strptime(text, fmt).date().isoformat()
        except ValueError:
            continue
    return None

def parse_date_from_title(title: str) -> str | None:
    title = title or ""
    for pat, fmts in DATE_PATTERNS:
        m = re.search(pat, title)
        if not m:
            continue
        parsed = _try_parse_with_formats(m.group(1), fmts)
        if parsed:
            return parsed
    return None

def _parse_isoish_datetime(s: str) -> datetime | None:
    """Parse common ISO-like strings without third-party libs."""
    s = s.strip()
    # Handle trailing Z
    if s.endswith("Z"):
        s = s[:-1] + "+00:00"
    # If no timezone info, try plain fromisoformat
    try:
        return datetime.fromisoformat(s)
    except ValueError:
        pass
    # Very loose fallback: extract a YYYY-MM-DD first
    m = re.search(r"\d{4}-\d{2}-\d{2}", s)
    if m:
        try:
            d = datetime.strptime(m.group(0), "%Y-%m-%d")
            return d
        except ValueError:
            pass
    return None

def best_date_for_filename(note_meta: dict) -> str:
    # 1) date in title  2) createdAt (ms or ISO-ish)  3) today (UTC)
    title = (note_meta.get("title") or "").strip()
    d = parse_date_from_title(title)
    if d:
        return d

    created = note_meta.get("createdAt") or note_meta.get("created_at")
    if created is not None:
        # created can be ms epoch (int/float or numeric string) or an ISO-like string
        try:
            if isinstance(created, (int, float)) or (isinstance(created, str) and created.isdigit()):
                ms = float(created)
                dt = datetime.fromtimestamp(ms / 1000.0, tz=timezone.utc)
                return dt.date().isoformat()
            elif isinstance(created, str):
                dt = _parse_isoish_datetime(created)
                if dt:
                    return dt.date().isoformat()
        except Exception:
            pass

    return datetime.now(timezone.utc).date().isoformat()

def sanitize(name: str) -> str:
    return re.sub(r"[^\w\-. ]+", "_", name).strip().rstrip(".")

# NEW: helper to read the latest YYYY-MM-DD.md in a directory
def latest_date_from_dir(dir_path: pathlib.Path) -> str | None:
    """
    Scan dir_path for files named like YYYY-MM-DD.md and return the latest date string.
    Returns None if no matching files exist.
    """
    if not dir_path.exists():
        return None
    latest: str | None = None
    for p in dir_path.iterdir():
        if not p.is_file():
            continue
        m = re.fullmatch(r"(\d{4}-\d{2}-\d{2})\.md", p.name)
        if not m:
            continue
        ds = m.group(1)
        # validate the date (avoids 2025-13-99.md, etc.)
        try:
            datetime.strptime(ds, "%Y-%m-%d")
        except ValueError:
            continue
        if latest is None or ds > latest:  # ISO date strings compare lexicographically
            latest = ds
    return latest

if __name__ == "__main__":
    token = ""  # put your token here if required by your HackMD
    s = session_with_token(token)

    # NEW: determine cutoff date from meeting_notes directory
    cutoff_date = latest_date_from_dir(MEETING_NOTES_DIR)
    if cutoff_date:
        print(f"Incremental export: only creating notes after {cutoff_date}.")
    else:
        print("No existing meeting notes found; exporting all matched notes.")

    print("Fetching team notes …")
    notes = list_team_notes(s)
    print(f"Found {len(notes)} notes in team '{TEAM}'.")

    matched = []
    for n in notes:
        note_tags = {str(t).lower() for t in (n.get("tags") or [])}
        if note_tags & {t.lower() for t in TAGS}:
            matched.append(n)

    print(f"Matched {len(matched)} notes with tags {sorted(TAGS)}.")
    OUT_DIR.mkdir(parents=True, exist_ok=True)

    for n in matched:
        nid = n.get("id") or n.get("noteId") or n.get("shortId")
        if not nid:
            continue

        detail = get_note(s, nid)  # includes content
        content = detail.get("content") or ""
        title = (detail.get("title") or n.get("title") or "").strip()

        date_str = best_date_for_filename({**n, **detail})

        # NEW: skip notes on/before the cutoff date (if any)
        if cutoff_date and date_str <= cutoff_date:
            print(f"Skipping {title!r} ({date_str}) — on/before cutoff {cutoff_date}.")
            continue

        fname = sanitize(date_str) + ".md"

        these_tags = sorted(
            {t for t in (n.get("tags") or []) if t and t.lower() in {x.lower() for x in TAGS}}
        ) or ["misc"]

        for t in these_tags:
            outdir = OUT_DIR / t
            outdir.mkdir(parents=True, exist_ok=True)
            outpath = outdir / fname

            # Minimal: overwrite if same date repeats
            body = content
            if not re.match(r"^\s*#\s+", body):
                body = f"# {title}\n\n{body}"
            outpath.write_text(body, encoding="utf-8")
            print(f"Saved {outpath}")
